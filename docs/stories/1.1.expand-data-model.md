# Story 1.1: 擴展資料模型以支援新功能

## Status

Draft

## Story

**As a** 系統開發者,  
**I want** 擴展 Album 資料模型以包含年份、類型和封面 URL 欄位,  
**so that** 系統可以儲存和展示更豐富的專輯資訊。

## Acceptance Criteria

1. 使用 Alembic 建立資料庫遷移腳本
2. 在 Album 模型中新增以下欄位（全部為 nullable）：
   - `year` (Integer, nullable)
   - `genre` (String(100), nullable)
   - `cover_url` (String(500), nullable)
3. 更新 Pydantic schemas (AlbumCreate, AlbumUpdate, AlbumOut) 以包含新欄位
4. 現有的專輯記錄不受影響（新欄位為 NULL）
5. 現有的 API 端點繼續正常運作
6. 資料庫遷移可以安全地回滾

## Integration Verification

IV1: 驗證現有的專輯建立、讀取、更新、刪除功能仍然正常運作
IV2: 驗證現有的搜尋功能（依標題）不受影響
IV3: 驗證現有資料在遷移後完整保留
IV4: 驗證新欄位可以正確儲存和讀取

## Tasks / Subtasks

- [ ] Task 1: Set up Alembic migration system (AC: 1, 6)
  - [ ] Initialize Alembic in project root: `alembic init alembic`
  - [ ] Configure `alembic/env.py` to use existing database connection from `database.py`
  - [ ] Update `alembic.ini` to point to correct database URL (use DATABASE_URL env var or default to SQLite)
  - [ ] Test Alembic connection: `alembic current`
  
- [ ] Task 2: Update Album model in models.py (AC: 2)
  - [ ] Add `year: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)` to Album class
  - [ ] Add `genre: Mapped[Optional[str]] = mapped_column(String(100), nullable=True)` to Album class
  - [ ] Add `cover_url: Mapped[Optional[str]] = mapped_column(String(500), nullable=True)` to Album class
  - [ ] Verify model follows existing pattern (Mapped type hints, SQLAlchemy 2.0 style)
  
- [ ] Task 3: Create database migration script (AC: 1, 2, 4)
  - [ ] Generate migration: `alembic revision --autogenerate -m "Add year genre cover_url to albums"`
  - [ ] Review generated migration script in `alembic/versions/`
  - [ ] Verify migration adds three nullable columns to albums table
  - [ ] Ensure migration is reversible (has both upgrade and downgrade functions)
  
- [ ] Task 4: Update Pydantic schemas in schemas.py (AC: 3)
  - [ ] Add `year: Optional[int] = Field(default=None)` to AlbumCreate class
  - [ ] Add `genre: Optional[str] = Field(default=None, max_length=100)` to AlbumCreate class
  - [ ] Add `cover_url: Optional[str] = Field(default=None, max_length=500)` to AlbumCreate class
  - [ ] Add same fields to AlbumUpdate class (all Optional)
  - [ ] Add same fields to AlbumOut class (all Optional)
  - [ ] Verify Config class uses `from_attributes = True` for ORM compatibility
  
- [ ] Task 5: Apply database migration (AC: 4, 6)
  - [ ] Run migration: `alembic upgrade head`
  - [ ] Verify migration applied successfully
  - [ ] Check existing album records still exist and have NULL for new fields
  - [ ] Test rollback: `alembic downgrade -1` then `alembic upgrade head`
  
- [ ] Task 6: Update main.py startup to use Alembic instead of create_all (AC: 5)
  - [ ] Remove or comment out `Base.metadata.create_all(bind=engine)` from `on_startup` function
  - [ ] Ensure Alembic migrations are run before application starts (manual step or startup check)
  - [ ] Verify application still starts correctly
  
- [ ] Task 7: Integration verification testing (AC: 4, 5, IV1-IV4)
  - [ ] Test existing POST /users/{user_id}/albums endpoint still works
  - [ ] Test existing GET /users/{user_id}/albums endpoint still works
  - [ ] Test existing PUT /users/{user_id}/albums/{album_id} endpoint still works
  - [ ] Test existing DELETE /users/{user_id}/albums/{album_id} endpoint still works
  - [ ] Test existing search functionality (q parameter) still works
  - [ ] Test creating album with new fields (year, genre, cover_url)
  - [ ] Test updating album with new fields
  - [ ] Verify existing albums have NULL for new fields (not broken)
  - [ ] Test API responses include new fields (when provided)

## Dev Notes

### Previous Story Insights

This is the first story in Epic 1, so there are no previous story insights.

### Data Models

**Current Album Model** (`models.py`):
- Uses SQLAlchemy 2.0 style with `Mapped` type hints
- Pattern: `Mapped[Optional[type]] = mapped_column(Type(length), nullable=True)`
- Existing fields: id, title, normalized_title, barcode, artist, owner_id
- Has unique constraints and indexes defined in `__table_args__`
- Relationship: `owner: Mapped[User] = relationship(back_populates="albums")`

**New Fields to Add** [Source: docs/prd/epic-1.md#story-11]:
- `year`: Integer, nullable
- `genre`: String(100), nullable  
- `cover_url`: String(500), nullable

**Model Pattern to Follow** [Source: docs/architecture.md#data-models]:
```python
barcode: Mapped[Optional[str]] = mapped_column(String(64), nullable=True, index=True)
artist: Mapped[Optional[str]] = mapped_column(String(255), nullable=True)
```

### API Specifications

**Current Pydantic Schemas** (`schemas.py`):
- `AlbumCreate`: Used for POST requests, all fields Optional with Field() constraints
- `AlbumUpdate`: Used for PUT requests, all fields Optional
- `AlbumOut`: Used for responses, includes id and owner_id, uses `from_attributes = True`

**Schema Pattern to Follow** [Source: schemas.py]:
```python
class AlbumCreate(BaseModel):
    title: Optional[str] = Field(default=None, max_length=255)
    barcode: Optional[str] = Field(default=None, max_length=64)
    artist: Optional[str] = Field(default=None, max_length=255)
```

**API Endpoints Affected** [Source: docs/architecture.md#api-specifications]:
- `POST /users/{user_id}/albums` - Will accept new fields in request body
- `GET /users/{user_id}/albums` - Will return new fields in response
- `PUT /users/{user_id}/albums/{album_id}` - Will accept new fields in request body
- `GET /users/{user_id}/albums/check` - May return new fields in album object

All endpoints use Pydantic models, so adding fields to schemas automatically updates API contract.

### File Locations

**Files to Modify** [Source: docs/architecture.md#enhancement-impact-analysis]:
- `models.py` - Add new fields to Album model
- `schemas.py` - Add new fields to AlbumCreate, AlbumUpdate, AlbumOut
- `main.py` - Remove `Base.metadata.create_all()` from startup (use Alembic instead)

**New Files/Directories to Create**:
- `alembic/` directory - Alembic migration system
- `alembic.ini` - Alembic configuration file
- `alembic/env.py` - Alembic environment configuration
- `alembic/versions/` - Migration script files
- `alembic/script.py.mako` - Migration template

### Technical Constraints

**Database Migration Requirements** [Source: docs/architecture.md#technical-debt]:
- Currently uses `Base.metadata.create_all()` which is not suitable for production
- Alembic is in requirements.txt (version 1.15.2) but NOT configured
- Must set up Alembic from scratch
- Migration must be reversible (downgrade function)

**Backward Compatibility** [Source: docs/prd/epic-1.md#integration-requirements]:
- All new fields MUST be nullable to not break existing data
- Existing API endpoints must continue to work
- Existing album records must remain intact after migration

**SQLAlchemy Patterns** [Source: docs/architecture.md#data-models]:
- Use SQLAlchemy 2.0 style with `Mapped` type hints
- Follow existing pattern: `Mapped[Optional[type]] = mapped_column(...)`
- No need to add indexes for new fields (not used in queries yet)

**Database Connection** [Source: database.py]:
- Uses `DATABASE_URL` environment variable (defaults to `sqlite:///./albums.db`)
- Alembic must use same connection string
- SQLite requires `check_same_thread=False` (handled in database.py)

### Integration Considerations

**Existing Code Patterns** [Source: docs/architecture.md#key-modules]:
- All business logic in `main.py` route handlers (no service layer)
- Uses FastAPI dependency injection: `db: Session = Depends(get_db)`
- Session management: `autoflush=False, autocommit=False` - must explicitly commit
- Error handling: Uses HTTPException with custom status codes

**Startup Behavior** [Source: main.py]:
- Currently: `Base.metadata.create_all(bind=engine)` in `on_startup` function
- Must change to: Use Alembic migrations (run manually or check on startup)
- Application should verify migrations are up-to-date on startup

**Testing Considerations**:
- No existing test suite (pytest available but no tests)
- Manual testing required for integration verification
- Test with existing data in database (not empty database)

### Testing

**Testing Standards** [Source: docs/architecture.md#testing-reality]:
- pytest is installed (version 8.3.5) but no tests exist
- No test directory structure exists
- Manual testing is current primary QA method

**Testing Requirements for This Story**:
- Manual integration testing of all affected API endpoints
- Verify existing data integrity after migration
- Test migration rollback functionality
- Verify new fields can be set and retrieved via API

**Test Scenarios**:
1. Create album without new fields (backward compatibility)
2. Create album with new fields (forward compatibility)
3. Update album to add new fields
4. Update album to remove new fields (set to None)
5. Retrieve album and verify new fields in response
6. Verify existing albums have NULL for new fields
7. Test migration rollback and re-apply

**No Automated Tests Required**: Since no test infrastructure exists, focus on manual verification and integration testing.

## Change Log

| Date       | Version | Description                    | Author        |
| ---------- | ------- | ------------------------------ | ------------- |
| 2025-11-23 | 1.0     | Initial story creation         | Scrum Master  |

## Dev Agent Record

### Agent Model Used

_To be filled by Dev Agent_

### Debug Log References

_To be filled by Dev Agent_

### Completion Notes List

_To be filled by Dev Agent_

### File List

_To be filled by Dev Agent_

## QA Results

_To be filled by QA Agent_

